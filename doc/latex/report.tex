\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{letterpaper}

\usepackage{graphicx}
\usepackage{amssymb, amsmath}
\usepackage{epstopdf}
% \usepackage{natbib}
\usepackage[hyperref=auto,style=alphabetic,backend=bibtex]{biblatex}
\usepackage[colorlinks]{hyperref}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\addbibresource{report.bib}

%\title{Title}
%\author{Name 1, Name 2}
%\date{date}

\begin{document}


\input{cover}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Agreement for free-download}
\bigskip


\bigskip


\large We hereby agree to make our source code for this project freely available for download from the web pages of the SOMS chair.
Furthermore, we assure that all source code is written by ourselves and is not violating any copyright restrictions.

\begin{center}

\bigskip


\bigskip

Jan Wilken D\"{o}rrie \hfill Simone Forte \hfill Charalampos Gkonos \hfill Athina Korfiati

\end{center}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% IMPORTANT
% you MUST include the ETH declaration of originality here; it is available for download on the course website or at http://www.ethz.ch/faculty/exams/plagiarism/index_EN; it can be printed as pdf and should be filled out in handwriting


%%%%%%%%%% Table of content %%%%%%%%%%%%%%%%%

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Abstract}

\section{Individual contributions}

\section{Introduction and Motivations}

\section{Description of the Model}
The model we developed is loosely based on cellular automata. Every car is thus represented as an automaton which acts according to a very simple update rule; all the transitions will happen on a graph which represents the road network of a city, in this particular case this will be the city of Zurich. The model has two main parts:
\begin{itemize}
\item \textbf{Journey generation}: for every automaton we will generate a path that it will follow; this route will be fixed at the beginning and it will stay unchanged for the rest of the simulation. The way this routes will be generated will be based on a probability distribution defined by the CSVs files population.csv and companies.csv; what we aimed at modeling was the everyday morning journey of people from their houses to the workplace; we will thus have that the sources of the paths will be generated with a probability proportional to the number of people living in a certain area of the city and the destinations will be generated with a probability proportional to the number of companies situated in a certain area. Additionally to the city of Zurich we also took into account the population living in smaller towns south of the river which we aggregated as incoming and outgoing from the major highways located in the south of Zurich; this has been necessary in order to evaluate the impact of a tunnel in that area.
\item \textbf{Route planning}:  After the intended journey for an automaton has been generated we will generate the actual path that the automaton intends to follow. We have in particular considered a realistic assumption that the paths will be decided at the beginning of the journey to be the shortest path between two locations and will remain unchanged regardless of the traffic situation of a road.
\item \textbf{Journey execution}: At this point the automaton knows the actual path it wants to follow. It will thus be initialized in its starting location and at every time step, having length in milliseconds equal to \textbf{m}, it will simply advance of a quantity equal to the minimum between the distance it can travel given that it travel for \textbf{m} milliseconds at the maximum speed allowed by the road it is following and the distance of the next car on the path minus a safety distance. To decide in which order update the cars in a timestep we will simply iterate on the cars in a random order and all the decisions for a car will be taken considering the position of the other cars at the time in which the car is updated.
\end{itemize}

\section{Implementation}
We started out by extracting the OpenStreetMap file that contains Zurich.
In order to do so we downloaded a recent Switzerland extract from Geofabrik \cite{geofab} and then extracted the boundaries of Zurich with the tool \emph{Osmconvert} \cite{osmconv}.
Afterwards we used another tool called \emph{Osmosis} to limit our data to the roads in Zurich.
Furthermore we modified the data using JOSM which enabled us to simplify the road network, making our algorithms more efficient.
Once we removed small isolated connected components resulting from clipping the data to Zurich we wrote an A-Star algorithm implementation in C++.
We considered doing this directly in Matlab, however the performance loss was too large, so that we wrote the mex file.

The MATLAB implementation mostly consists of two parts, an initialization part and an update part. In the initialization the main data structures and parameters of the model are set up; we thus generate the routes for every car, picking starting and ending location according to a probability distribution specified by the CSVs files (reference...) and the actual path will be generated by computing the shortest path between the two locations. In the update part, for every timestep, we compute the new locations of every car according to the way specified earlier in the Description of the Model section and we compute the new GEO coordinates of the cars which are then given back to the Javascript client.


Finally we made use of the Javascript Library Leaflet to visualize our results on the actual map of Zurich.
We enabled communication between MATLAB and Javascript using the included Java classes for Sockets.
The Javascript code issues HTTP GET requests telling the MATLAB implementation which methods to perform.
Afterwards the location of every car in Zurich was passed as an JSON object through the socket.


\section{Simulation Results and Discussion}

\section{Summary and Outlook}

% \section{References}

\newpage
\printbibliography


\end{document}




